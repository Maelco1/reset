<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Administration - Gestion des gardes</title>
    <link rel="stylesheet" href="assets/css/styles.css" />
  </head>
  <body>
    <div id="connection-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true">
      <section class="modal">
        <h1>Connexion à Supabase</h1>
        <p>Pour gérer les comptes, configurez l'accès à votre instance Supabase.</p>
        <form id="connection-form" class="card">
          <label for="supabaseUrl">URL Supabase</label>
          <input id="supabaseUrl" name="supabaseUrl" type="url" required />

          <label for="supabaseKey">Clé API</label>
          <input id="supabaseKey" name="supabaseKey" type="password" required />

          <div class="stack" style="justify-content: flex-end;">
            <button type="submit">Se connecter</button>
          </div>
        </form>
      </section>
    </div>
    <main>
      <section class="card admin-shell">
        <header>
          <div>
            <h1>Espace administrateur</h1>
            <p>Gérez les comptes grâce aux trigrammes de vos collaborateurs.</p>
          </div>
          <nav>
            <button id="disconnect" class="secondary" type="button">Changer d'instance</button>
            <button id="logout" class="secondary" type="button">Se déconnecter</button>
          </nav>
        </header>

        <section aria-labelledby="users-title" class="users-section">
          <div class="section-header">
            <h2 id="users-title">Comptes utilisateurs</h2>
            <p id="users-feedback" role="status"></p>
          </div>
          <div class="user-groups" id="user-groups"></div>
        </section>

        <section aria-labelledby="planning-title" class="planning-section">
          <div class="planning-surface">
            <div class="section-header planning-section-header">
              <h2 id="planning-title">Planning des gardes</h2>
              <p id="planning-feedback" role="status"></p>
            </div>

            <form id="planning-controls" class="planning-controls" aria-label="Filtres du planning">
              <div class="planning-control">
                <label for="planning-year">Année</label>
                <select id="planning-year" name="year"></select>
              </div>

              <div class="planning-control">
                <label for="planning-month-1">Mois 1</label>
                <select id="planning-month-1" name="month-1"></select>
              </div>

              <div class="planning-control">
                <label for="planning-month-2">Mois 2</label>
                <select id="planning-month-2" name="month-2"></select>
              </div>
            </form>

            <div class="planning-layout">
              <div class="planning-board" role="region" aria-labelledby="planning-title">
                <div class="planning-tables" id="planning-tables" aria-live="polite"></div>
              </div>
              <aside class="planning-sidebar" aria-labelledby="planning-config-title">
                <div class="planning-sidebar-header">
                  <h3 id="planning-config-title">Configuration des colonnes</h3>
                  <p>Ajoutez, modifiez ou supprimez les colonnes de votre planning.</p>
                </div>
                <div class="planning-config" id="planning-config" aria-live="polite"></div>
              </aside>
            </div>
          </div>
        </section>

        <footer class="admin-footer" aria-labelledby="create-title">
          <h2 id="create-title">Ajouter un utilisateur</h2>
          <p>Complétez les informations ci-dessous pour ajouter un nouveau compte.</p>
          <form id="create-user-form" class="compact-form">
            <div class="form-grid">
              <label for="new-username">Identifiant</label>
              <input id="new-username" name="username" type="text" autocomplete="off" required />

              <label for="new-trigram">Trigramme</label>
              <input
                id="new-trigram"
                name="trigram"
                type="text"
                inputmode="text"
                maxlength="3"
                autocomplete="off"
                required
                class="uppercase-input"
              />

              <label for="new-password">Mot de passe</label>
              <input id="new-password" name="password" type="password" autocomplete="new-password" required />

              <label for="new-role">Rôle</label>
              <select id="new-role" name="role" required>
                <option value="administrateur">Administrateur</option>
                <option value="medecin">Médecin</option>
                <option value="remplacant">Remplaçant</option>
              </select>
            </div>

            <button type="submit" class="subtle-button">Ajouter l'utilisateur</button>
            <p id="create-feedback" role="status"></p>
          </form>
        </footer>
      </section>
    </main>

    <div id="user-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="user-modal-title">
      <section class="modal user-modal">
        <header class="modal-header">
          <div>
            <h2 id="user-modal-title">Gérer l'utilisateur</h2>
            <p id="user-modal-subtitle"></p>
          </div>
          <button type="button" class="icon-button" id="close-user-modal" aria-label="Fermer">&times;</button>
        </header>
        <form id="edit-user-form">
          <input type="hidden" id="edit-user-id" name="id" />

          <label for="edit-username">Identifiant</label>
          <input id="edit-username" name="username" type="text" autocomplete="off" />

          <label for="edit-trigram">Trigramme</label>
          <input
            id="edit-trigram"
            name="trigram"
            type="text"
            maxlength="3"
            autocomplete="off"
            required
            class="uppercase-input"
          />

          <label for="edit-role">Rôle</label>
          <select id="edit-role" name="role" required>
            <option value="administrateur">Administrateur</option>
            <option value="medecin">Médecin</option>
            <option value="remplacant">Remplaçant</option>
          </select>

          <label for="edit-password">Nouveau mot de passe</label>
          <input id="edit-password" name="password" type="password" autocomplete="new-password" placeholder="Laisser vide pour ne pas changer" />

          <div class="modal-actions">
            <button type="submit">Enregistrer</button>
            <button type="button" id="delete-user" class="danger">Supprimer</button>
          </div>
        </form>
      </section>
    </div>

    <div id="slot-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="slot-modal-title">
      <section class="modal planning-modal">
        <header class="modal-header">
          <div>
            <h2 id="slot-modal-title">Configurer le créneau</h2>
            <p id="slot-modal-subtitle"></p>
          </div>
          <button type="button" class="icon-button" id="close-slot-modal" aria-label="Fermer">&times;</button>
        </header>

        <form id="slot-form">
          <input type="hidden" name="position" id="slot-position" />

          <div class="slot-grid">
            <div class="slot-field-group">
              <label for="slot-label">Nom de la colonne</label>
              <input id="slot-label" name="label" type="text" required />
            </div>

            <div class="slot-field-group">
              <label for="slot-type-code">Type de colonne (acronyme)</label>
              <input id="slot-type-code" name="typeCode" type="text" required />
            </div>

            <div class="slot-field-group">
              <label for="slot-type-category">Catégorie</label>
              <select id="slot-type-category" name="typeCategory" required>
                <option value="Visite">Visite</option>
                <option value="Consultation">Consultation</option>
                <option value="Téléconsultation">Téléconsultation</option>
              </select>
            </div>

            <div class="slot-field-group">
              <label for="slot-color">Couleur</label>
              <input id="slot-color" name="color" type="color" value="#1e293b" />
            </div>
          </div>

          <div class="slot-times">
            <div class="slot-field-group">
              <label for="slot-start">Début</label>
              <input id="slot-start" name="startTime" type="time" />
            </div>
            <div class="slot-field-group">
              <label for="slot-end">Fin</label>
              <input id="slot-end" name="endTime" type="time" />
            </div>
          </div>
          <fieldset class="slot-qualities">
            <legend>Qualité par période</legend>
            <div class="slot-qualities-grid">
              <label for="slot-quality-weekdays">Lun - Ven</label>
              <select id="slot-quality-weekdays" name="qualityWeekdays" required>
                <option value="Mauvaise">Mauvaise</option>
                <option value="Bonus">Bonus</option>
              </select>

              <label for="slot-quality-saturday">Samedi</label>
              <select id="slot-quality-saturday" name="qualitySaturday" required>
                <option value="Mauvaise">Mauvaise</option>
                <option value="Bonus">Bonus</option>
              </select>

              <label for="slot-quality-sunday">Dimanche / Férié</label>
              <select id="slot-quality-sunday" name="qualitySunday" required>
                <option value="Mauvaise">Mauvaise</option>
                <option value="Bonus">Bonus</option>
              </select>
            </div>
          </fieldset>

          <fieldset class="slot-openings">
            <legend>Ouverture des cases</legend>
            <div class="slot-openings-grid">
              <div>
                <h3>Mauvaise</h3>
                <label for="slot-open-mauvaise-weekdays">Lun - Ven</label>
                <select id="slot-open-mauvaise-weekdays" name="openMauvaiseWeekdays" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>

                <label for="slot-open-mauvaise-saturday">Samedi</label>
                <select id="slot-open-mauvaise-saturday" name="openMauvaiseSaturday" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>

                <label for="slot-open-mauvaise-sunday">Dimanche / Férié</label>
                <select id="slot-open-mauvaise-sunday" name="openMauvaiseSunday" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>
              </div>
              <div>
                <h3>Bonus</h3>
                <label for="slot-open-bonus-weekdays">Lun - Ven</label>
                <select id="slot-open-bonus-weekdays" name="openBonusWeekdays" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>

                <label for="slot-open-bonus-saturday">Samedi</label>
                <select id="slot-open-bonus-saturday" name="openBonusSaturday" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>

                <label for="slot-open-bonus-sunday">Dimanche / Férié</label>
                <select id="slot-open-bonus-sunday" name="openBonusSunday" required>
                  <option value="true">Oui</option>
                  <option value="false">Non</option>
                </select>
              </div>
            </div>
          </fieldset>

          <div class="modal-actions">
            <button type="submit">Enregistrer</button>
            <button type="button" class="secondary" id="cancel-slot">Annuler</button>
          </div>
          <p id="slot-feedback" role="status"></p>
        </form>
      </section>
    </div>

    <script type="module">
      import {
        initializeConnectionModal,
        requireRole,
        getCurrentUser,
        setCurrentUser,
        getSupabaseClient,
        onSupabaseReady
      } from './js/supabaseClient.js';

      const DEFAULT_COLOR = '#1e293b';
      const COLUMN_DEFAULTS = [
        { position: 1, typeCode: '1N', color: '#1e293b' },
        { position: 2, typeCode: '2N', color: '#1e293b' },
        { position: 3, typeCode: '3N', color: '#1e293b' },
        { position: 4, typeCode: '4C', color: '#1e293b' },
        { position: 5, typeCode: '5S', color: '#1e293b' },
        { position: 6, typeCode: '6S', color: '#1e293b' },
        { position: 7, typeCode: 'VIS', color: '#1e293b' },
        { position: 8, typeCode: 'VIS', color: '#1e293b' },
        { position: 9, typeCode: 'VIS', color: '#1e293b' },
        { position: 10, typeCode: 'VIS', color: '#1e293b' },
        { position: 11, typeCode: 'VIS', color: '#1e293b' },
        { position: 12, typeCode: 'TC', color: '#1e293b' },
        { position: 13, typeCode: 'C1COU', color: '#1e293b' },
        { position: 14, typeCode: 'C2COU', color: '#1e293b' },
        { position: 15, typeCode: 'C1BOU', color: '#1e293b' },
        { position: 16, typeCode: 'C2BOU', color: '#1e293b' },
        { position: 17, typeCode: 'PFG', color: '#1e293b' },
        { position: 18, typeCode: 'C1ANT', color: '#1e293b' },
        { position: 19, typeCode: 'C2ANT', color: '#1e293b' },
        { position: 20, typeCode: 'TC', color: '#1e293b' },
        { position: 21, typeCode: 'N', color: '#1e293b' },
        { position: 22, typeCode: 'C', color: '#1e293b' },
        { position: 23, typeCode: 'S', color: '#1e293b' },
        { position: 24, typeCode: 'VIS', color: '#1e293b' },
        { position: 25, typeCode: 'VIS', color: '#1e293b' },
        { position: 26, typeCode: 'VIS', color: '#1e293b' },
        { position: 27, typeCode: 'C1COU', color: '#1e293b' },
        { position: 28, typeCode: 'C2COU', color: '#1e293b' },
        { position: 29, typeCode: 'C1BOU', color: '#1e293b' },
        { position: 30, typeCode: 'C2BOU', color: '#1e293b' },
        { position: 31, typeCode: 'PFG', color: '#1e293b' },
        { position: 32, typeCode: 'C1ANT', color: '#1e293b' },
        { position: 33, typeCode: 'C2ANT', color: '#1e293b' },
        { position: 34, typeCode: 'TC', color: '#1e293b' },
        { position: 35, typeCode: 'VIS', color: '#1e293b' },
        { position: 36, typeCode: 'PFG', color: '#1e293b' },
        { position: 37, typeCode: 'VIS', color: '#1e293b' },
        { position: 38, typeCode: 'VIS', color: '#1e293b' },
        { position: 39, typeCode: 'VIS', color: '#1e293b' },
        { position: 40, typeCode: 'VIS', color: '#1e293b' },
        { position: 41, typeCode: 'VIS', color: '#1e293b' },
        { position: 42, typeCode: 'VIS', color: '#1e293b' },
        { position: 43, typeCode: 'TCN', color: '#1e293b' },
        { position: 44, typeCode: 'VIS', color: '#1e293b' },
        { position: 45, typeCode: 'VIS', color: '#1e293b' },
        { position: 46, typeCode: 'VIS', color: '#1e293b' }
      ];
      const TYPE_CATEGORY_MAP = new Map([
        ...[
          '1N',
          '2N',
          '3N',
          '4C',
          '5S',
          '6S',
          'N',
          'C',
          'S',
          'VIS'
        ].map((code) => [code, 'Visite']),
        ...[
          'C1COU',
          'C2COU',
          'C1BOU',
          'C2BOU',
          'PFG',
          'C1ANT',
          'C2ANT',
          'C1',
          'C2',
          'C3'
        ].map((code) => [code, 'Consultation']),
        ...['TC', 'TCN'].map((code) => [code, 'Téléconsultation'])
      ]);
      const WEEKDAY_LABELS = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
      const MONTH_NAMES = [
        'Janvier',
        'Février',
        'Mars',
        'Avril',
        'Mai',
        'Juin',
        'Juillet',
        'Août',
        'Septembre',
        'Octobre',
        'Novembre',
        'Décembre'
      ];

      const currentUser = getCurrentUser();
      if (!currentUser) {
        window.location.replace('index.html');
      }
      requireRole('administrateur');

      initializeConnectionModal();

      const logoutBtn = document.querySelector('#logout');
      logoutBtn.addEventListener('click', () => {
        setCurrentUser(null);
        window.location.replace('index.html');
      });

      const createForm = document.querySelector('#create-user-form');
      const createFeedback = document.querySelector('#create-feedback');
      const usersFeedback = document.querySelector('#users-feedback');
      const userGroups = document.querySelector('#user-groups');
      const userModal = document.querySelector('#user-modal');
      const userModalSubtitle = document.querySelector('#user-modal-subtitle');
      const editForm = document.querySelector('#edit-user-form');
      const deleteUserBtn = document.querySelector('#delete-user');
      const closeUserModalBtn = document.querySelector('#close-user-modal');
      const trigramInputs = document.querySelectorAll('.uppercase-input');

      const planningYearSelect = document.querySelector('#planning-year');
      const planningMonthOneSelect = document.querySelector('#planning-month-1');
      const planningMonthTwoSelect = document.querySelector('#planning-month-2');
      const planningConfigContainer = document.querySelector('#planning-config');
      const planningTables = document.querySelector('#planning-tables');
      const planningFeedback = document.querySelector('#planning-feedback');

      const slotModal = document.querySelector('#slot-modal');
      const slotModalSubtitle = document.querySelector('#slot-modal-subtitle');
      const slotForm = document.querySelector('#slot-form');
      const slotFeedback = document.querySelector('#slot-feedback');
      const closeSlotModalBtn = document.querySelector('#close-slot-modal');
      const cancelSlotBtn = document.querySelector('#cancel-slot');

      const slotTypeCodeInput = slotForm?.elements['typeCode'];
      if (slotTypeCodeInput) {
        slotTypeCodeInput.addEventListener('input', () => {
          const sanitized = slotTypeCodeInput.value.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
          slotTypeCodeInput.value = sanitized;
          const mappedCategory = TYPE_CATEGORY_MAP.get(sanitized);
          if (mappedCategory && slotForm.elements['typeCategory']) {
            slotForm.elements['typeCategory'].value = mappedCategory;
          }
        });
      }

      const formatTrigram = (value) => value.replace(/[^a-zA-Z0-9]/g, '').slice(0, 3).toUpperCase();
      trigramInputs.forEach((input) => {
        input.addEventListener('input', () => {
          input.value = formatTrigram(input.value);
        });
      });

      let editingUser = null;
      let editingSlot = null;
      let usersChannel;
      let planningChannel;
      let allUsers = [];
      let planningSlots = [];
      let planningLoading = false;
      let openPlanningConfigMenu = null;

      const sanitizeColor = (value) => {
        if (typeof value !== 'string') {
          return null;
        }
        const trimmed = value.trim();
        if (/^#[0-9a-fA-F]{6}$/.test(trimmed)) {
          return trimmed.toLowerCase();
        }
        if (/^#[0-9a-fA-F]{3}$/.test(trimmed)) {
          const [r, g, b] = trimmed
            .slice(1)
            .split('')
            .map((char) => char + char);
          return `#${r}${g}${b}`.toLowerCase();
        }
        return null;
      };

      const normalizeColor = (value) => sanitizeColor(value) ?? DEFAULT_COLOR;

      const hexToRgba = (hex, alpha) => {
        const sanitized = sanitizeColor(hex) ?? DEFAULT_COLOR;
        const numeric = sanitized.slice(1);
        const r = parseInt(numeric.slice(0, 2), 16);
        const g = parseInt(numeric.slice(2, 4), 16);
        const b = parseInt(numeric.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };

      const getContrastingTextColor = (hex) => {
        const sanitized = sanitizeColor(hex) ?? DEFAULT_COLOR;
        const numeric = sanitized.slice(1);
        const r = parseInt(numeric.slice(0, 2), 16);
        const g = parseInt(numeric.slice(2, 4), 16);
        const b = parseInt(numeric.slice(4, 6), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.6 ? '#1e293b' : '#ffffff';
      };

      const inferTypeCategory = (typeCode) => {
        if (typeof typeCode !== 'string') {
          return 'Visite';
        }
        const normalized = typeCode.trim().toUpperCase();
        return TYPE_CATEGORY_MAP.get(normalized) ?? 'Visite';
      };

      const sanitizeQuality = (value) => (value === 'Bonus' ? 'Bonus' : 'Mauvaise');

      const toBoolean = (value, fallback = true) => {
        if (value === null || value === undefined) {
          return fallback;
        }
        if (typeof value === 'boolean') {
          return value;
        }
        if (typeof value === 'number') {
          return value !== 0;
        }
        const str = String(value).toLowerCase();
        return str === 'true' || str === '1' || str === 'yes' || str === 'oui';
      };

      const formatBoolean = (value) => (value ? 'Oui' : 'Non');

      const getSlotTimeRange = (slot) => {
        const start = (slot.start_time ?? '').trim();
        const end = (slot.end_time ?? '').trim();
        if (start && end) {
          return `${start} – ${end}`;
        }
        if (start) {
          return `Début ${start}`;
        }
        if (end) {
          return `Fin ${end}`;
        }
        return '';
      };

      const selectToBoolean = (value, fallback = true) => {
        if (value === 'true') {
          return true;
        }
        if (value === 'false') {
          return false;
        }
        return fallback;
      };

      const getDefaultSlot = (position) => {
        const defaults = COLUMN_DEFAULTS.find((item) => item.position === position);
        const typeCode = defaults?.typeCode ?? `COL${String(position).padStart(2, '0')}`;
        const category = inferTypeCategory(typeCode);
        return {
          position,
          label: typeCode,
          type_code: typeCode,
          type_category: category,
          start_time: null,
          end_time: null,
          color: defaults?.color ?? DEFAULT_COLOR,
          quality_weekdays: 'Mauvaise',
          quality_saturday: 'Mauvaise',
          quality_sunday: 'Mauvaise',
          open_mauvaise_weekdays: true,
          open_mauvaise_saturday: true,
          open_mauvaise_sunday: true,
          open_bonus_weekdays: true,
          open_bonus_saturday: true,
          open_bonus_sunday: true
        };
      };

      const addDays = (date, days) => {
        const clone = new Date(date);
        clone.setDate(clone.getDate() + days);
        return clone;
      };

      const formatDateKey = (date) =>
        `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

      const calculateEaster = (year) => {
        const a = year % 19;
        const b = Math.floor(year / 100);
        const c = year % 100;
        const d = Math.floor(b / 4);
        const e = b % 4;
        const f = Math.floor((b + 8) / 25);
        const g = Math.floor((b - f + 1) / 3);
        const h = (19 * a + b - d - g + 15) % 30;
        const i = Math.floor(c / 4);
        const k = c % 4;
        const l = (32 + 2 * e + 2 * i - h - k) % 7;
        const m = Math.floor((a + 11 * h + 22 * l) / 451);
        const month = Math.floor((h + l - 7 * m + 114) / 31);
        const day = ((h + l - 7 * m + 114) % 31) + 1;
        return new Date(year, month - 1, day);
      };

      const getFrenchHolidays = (year) => {
        const holidays = new Map();
        const addFixed = (month, day, label) => {
          holidays.set(formatDateKey(new Date(year, month, day)), label);
        };
        addFixed(0, 1, "Jour de l'An");
        addFixed(4, 1, 'Fête du Travail');
        addFixed(4, 8, 'Victoire 1945');
        addFixed(6, 14, 'Fête Nationale');
        addFixed(7, 15, 'Assomption');
        addFixed(10, 1, 'Toussaint');
        addFixed(10, 11, 'Armistice');
        addFixed(11, 25, 'Noël');

        const easter = calculateEaster(year);
        holidays.set(formatDateKey(addDays(easter, 1)), 'Lundi de Pâques');
        holidays.set(formatDateKey(addDays(easter, 39)), 'Ascension');
        holidays.set(formatDateKey(addDays(easter, 50)), 'Lundi de Pentecôte');

        return holidays;
      };

      const getMonthDays = (year, month) => {
        const days = [];
        const cursor = new Date(year, month, 1);
        while (cursor.getMonth() === month) {
          days.push(new Date(cursor));
          cursor.setDate(cursor.getDate() + 1);
        }
        return days;
      };

      const getDaySegment = (date, isHoliday) => {
        if (isHoliday || date.getDay() === 0) {
          return 'sunday';
        }
        if (date.getDay() === 6) {
          return 'saturday';
        }
        return 'weekday';
      };

      const getQualityForSegment = (slot, segment) => {
        if (segment === 'saturday') {
          return sanitizeQuality(slot.quality_saturday);
        }
        if (segment === 'sunday') {
          return sanitizeQuality(slot.quality_sunday);
        }
        return sanitizeQuality(slot.quality_weekdays);
      };

      const isSlotOpen = (slot, segment) => {
        const quality = getQualityForSegment(slot, segment);
        if (quality === 'Bonus') {
          if (segment === 'saturday') {
            return toBoolean(slot.open_bonus_saturday);
          }
          if (segment === 'sunday') {
            return toBoolean(slot.open_bonus_sunday);
          }
          return toBoolean(slot.open_bonus_weekdays);
        }
        if (segment === 'saturday') {
          return toBoolean(slot.open_mauvaise_saturday);
        }
        if (segment === 'sunday') {
          return toBoolean(slot.open_mauvaise_sunday);
        }
        return toBoolean(slot.open_mauvaise_weekdays);
      };

      const buildSlotTitle = (slot, dayLabel, isHoliday, holidayName, isOpen, quality) => {
        const details = [];
        const label = slot.label ?? `Créneau ${slot.position}`;
        details.push(label);
        if (slot.type_code) {
          details.push(`Type : ${slot.type_code}`);
        }
        if (slot.type_category) {
          details.push(slot.type_category);
        }
        const slotTime = getSlotTimeRange(slot);
        if (slotTime) {
          details.push(slotTime);
        }
        details.push(`Qualité : ${quality}`);
        details.push(isOpen ? 'Ouvert' : 'Fermé');
        if (isHoliday && holidayName) {
          details.push(holidayName);
        }
        return `${dayLabel} · ${details.join(' · ')}`;
      };

      const buildPlanningTable = (year, month, holidays) => {
        const table = document.createElement('table');
        table.className = 'planning-table';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const dayHeader = document.createElement('th');
        dayHeader.scope = 'col';
        dayHeader.className = 'planning-day-col';
        dayHeader.textContent = 'Jour';
        headerRow.appendChild(dayHeader);

        planningSlots.forEach((slot) => {
          const th = document.createElement('th');
          th.scope = 'col';
          const button = document.createElement('button');
          button.type = 'button';
          button.dataset.position = slot.position;
          button.className = 'planning-slot-button';
          const slotColor = normalizeColor(slot.color);
          button.style.setProperty('--slot-color', slotColor);
          const slotNumber = String(slot.position).padStart(2, '0');
          const rawLabel = (slot.label ?? '').trim();
          const slotLabel = rawLabel || `Colonne ${slot.position}`;
          const slotType = slot.type_code ?? '';
          const slotTime = getSlotTimeRange(slot);
          const buttonTitleParts = [slotNumber, slotLabel];
          if (slotType) {
            buttonTitleParts.push(slotType);
          }
          if (slotTime) {
            buttonTitleParts.push(slotTime);
          }
          const buttonTitle = buttonTitleParts.join(' · ');
          button.title = buttonTitle;
          button.setAttribute('aria-label', buttonTitle);
          const heading = document.createElement('span');
          heading.className = 'planning-slot-heading';
          const numberLabel = document.createElement('span');
          numberLabel.className = 'planning-slot-number';
          numberLabel.textContent = slotNumber;
          heading.appendChild(numberLabel);
          const titleLabel = document.createElement('span');
          titleLabel.className = 'planning-slot-title';
          titleLabel.textContent = slotLabel;
          heading.appendChild(titleLabel);
          button.appendChild(heading);
          const srLabel = document.createElement('span');
          srLabel.className = 'sr-only';
          srLabel.textContent = buttonTitle;
          button.appendChild(srLabel);
          th.appendChild(button);
          headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        const days = getMonthDays(year, month);
        days.forEach((day) => {
          const isoKey = formatDateKey(day);
          const holidayName = holidays?.get(isoKey) ?? null;
          const isHoliday = Boolean(holidayName);
          const row = document.createElement('tr');
          if (isHoliday) {
            row.classList.add('planning-holiday');
          }
          if (day.getDay() === 0) {
            row.classList.add('planning-sunday');
          }

          const dayCell = document.createElement('th');
          dayCell.scope = 'row';
          dayCell.className = 'planning-day-header';
          const dayName = WEEKDAY_LABELS[day.getDay()];
          const dayNumber = String(day.getDate()).padStart(2, '0');
          dayCell.innerHTML = `
            <span class="day-name">${dayName}</span>
            <span class="day-number">${dayNumber} ${MONTH_NAMES[month]}</span>
          `;
          if (holidayName) {
            const badge = document.createElement('span');
            badge.className = 'holiday-badge';
            badge.textContent = holidayName;
            dayCell.appendChild(badge);
          }
          row.appendChild(dayCell);

          planningSlots.forEach((slot) => {
            const cell = document.createElement('td');
            cell.className = 'planning-summary-cell';
            const slotColor = normalizeColor(slot.color);
            const segment = getDaySegment(day, isHoliday);
            const quality = getQualityForSegment(slot, segment);
            const open = isSlotOpen(slot, segment);
            const content = document.createElement('div');
            content.className = 'planning-summary-content';
            const typeLabel = document.createElement('span');
            typeLabel.className = 'planning-summary-label';
            typeLabel.textContent = slot.type_code ?? slot.label ?? `Colonne ${slot.position}`;
            content.appendChild(typeLabel);
            const slotTime = getSlotTimeRange(slot);
            if (slotTime) {
              const schedule = document.createElement('span');
              schedule.className = 'planning-summary-time';
              schedule.textContent = slotTime;
              content.appendChild(schedule);
            }
            cell.appendChild(content);

            if (open) {
              const textColor = getContrastingTextColor(slotColor);
              cell.classList.add('planning-summary-open');
              cell.style.setProperty('--planning-cell-color', slotColor);
              cell.style.setProperty('--planning-cell-text', textColor);
              cell.style.color = textColor;
            } else {
              cell.classList.add('planning-summary-closed');
            }

            cell.title = buildSlotTitle(slot, dayName, isHoliday, holidayName, open, quality);
            row.appendChild(cell);
          });

          tbody.appendChild(row);
        });

        table.appendChild(tbody);
        return table;
      };

      const populatePlanningControls = () => {
        if (!planningYearSelect || !planningMonthOneSelect || !planningMonthTwoSelect) {
          return;
        }
        const now = new Date();
        const currentYear = now.getFullYear();
        const years = [currentYear - 1, currentYear, currentYear + 1];
        planningYearSelect.innerHTML = years.map((year) => `<option value="${year}">${year}</option>`).join('');
        planningYearSelect.value = String(currentYear);

        const options = MONTH_NAMES.map((name, index) => `<option value="${index}">${name}</option>`).join('');
        planningMonthOneSelect.innerHTML = options;
        planningMonthTwoSelect.innerHTML = options;
        planningMonthOneSelect.value = String(now.getMonth());
        planningMonthTwoSelect.value = String((now.getMonth() + 1) % 12);
      };

      const renderPlanningConfig = () => {
        if (!planningConfigContainer) {
          return;
        }
        closePlanningConfigMenu();
        if (!planningSlots.length) {
          planningConfigContainer.innerHTML = '<p class="empty-planning">Chargement des colonnes…</p>';
          return;
        }

        planningConfigContainer.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'planning-config-list';

        const table = document.createElement('table');
        table.className = 'table planning-config-table';
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th scope="col">Colonne</th>
            <th scope="col">Type</th>
            <th scope="col">Horaires</th>
            <th scope="col">Couleur</th>
            <th scope="col">Qualités</th>
            <th scope="col">Ouverture Mauvaise</th>
            <th scope="col">Ouverture Bonus</th>
            <th scope="col">Actions</th>
          </tr>
        `;
        table.appendChild(thead);

        const tbody = document.createElement('tbody');

        planningSlots.forEach((slot) => {
          const row = document.createElement('tr');

          const colCell = document.createElement('td');
          const posBadge = document.createElement('span');
          posBadge.className = 'planning-config-position';
          posBadge.textContent = String(slot.position).padStart(2, '0');
          colCell.appendChild(posBadge);
          const labelText = (slot.label ?? `Colonne ${slot.position}`).trim();
          const typeText = (slot.type_code ?? '').trim();
          if (labelText && labelText.toLowerCase() !== typeText.toLowerCase()) {
            const name = document.createElement('div');
            name.className = 'planning-config-label';
            name.textContent = labelText;
            colCell.appendChild(name);
          }
          row.appendChild(colCell);

          const typeCell = document.createElement('td');
          const typeCode = document.createElement('div');
          typeCode.className = 'planning-config-type';
          typeCode.textContent = slot.type_code ?? '—';
          typeCell.appendChild(typeCode);
          if (slot.type_category) {
            const category = document.createElement('div');
            category.className = 'planning-config-category';
            category.textContent = slot.type_category;
            typeCell.appendChild(category);
          }
          row.appendChild(typeCell);

          const scheduleCell = document.createElement('td');
          const schedule = getSlotTimeRange(slot);
          scheduleCell.textContent = schedule || '—';
          row.appendChild(scheduleCell);

          const colorCell = document.createElement('td');
          colorCell.className = 'planning-config-color-cell';
          const swatch = document.createElement('span');
          swatch.className = 'planning-config-color';
          swatch.style.backgroundColor = normalizeColor(slot.color);
          swatch.setAttribute('aria-hidden', 'true');
          colorCell.appendChild(swatch);
          const colorValue = document.createElement('span');
          colorValue.className = 'sr-only';
          colorValue.textContent = normalizeColor(slot.color);
          colorCell.appendChild(colorValue);
          colorCell.title = normalizeColor(slot.color);
          row.appendChild(colorCell);

          const qualityCell = document.createElement('td');
          const qualities = [
            { label: 'Lun - Ven', value: slot.quality_weekdays },
            { label: 'Samedi', value: slot.quality_saturday },
            { label: 'Dim / Férié', value: slot.quality_sunday }
          ];
          qualities.forEach(({ label, value }) => {
            const line = document.createElement('div');
            line.className = 'planning-config-line';
            const strong = document.createElement('strong');
            strong.textContent = `${label} : `;
            line.appendChild(strong);
            const text = document.createElement('span');
            text.textContent = value;
            line.appendChild(text);
            qualityCell.appendChild(line);
          });
          row.appendChild(qualityCell);

          const mauvaiseCell = document.createElement('td');
          const mauvaiseStatuses = [
            { label: 'Lun - Ven', value: formatBoolean(slot.open_mauvaise_weekdays) },
            { label: 'Samedi', value: formatBoolean(slot.open_mauvaise_saturday) },
            { label: 'Dim / Férié', value: formatBoolean(slot.open_mauvaise_sunday) }
          ];
          mauvaiseStatuses.forEach(({ label, value }) => {
            const line = document.createElement('div');
            line.className = 'planning-config-line';
            const strong = document.createElement('strong');
            strong.textContent = `${label} : `;
            line.appendChild(strong);
            const text = document.createElement('span');
            text.textContent = value;
            line.appendChild(text);
            mauvaiseCell.appendChild(line);
          });
          row.appendChild(mauvaiseCell);

          const bonusCell = document.createElement('td');
          const bonusStatuses = [
            { label: 'Lun - Ven', value: formatBoolean(slot.open_bonus_weekdays) },
            { label: 'Samedi', value: formatBoolean(slot.open_bonus_saturday) },
            { label: 'Dim / Férié', value: formatBoolean(slot.open_bonus_sunday) }
          ];
          bonusStatuses.forEach(({ label, value }) => {
            const line = document.createElement('div');
            line.className = 'planning-config-line';
            const strong = document.createElement('strong');
            strong.textContent = `${label} : `;
            line.appendChild(strong);
            const text = document.createElement('span');
            text.textContent = value;
            line.appendChild(text);
            bonusCell.appendChild(line);
          });
          row.appendChild(bonusCell);

          const actionCell = document.createElement('td');
          actionCell.className = 'planning-config-actions';
          const menu = document.createElement('div');
          menu.className = 'planning-config-menu';
          const trigger = document.createElement('button');
          trigger.type = 'button';
          trigger.className = 'planning-config-trigger';
          trigger.setAttribute('aria-haspopup', 'true');
          trigger.setAttribute('aria-expanded', 'false');
          trigger.innerHTML = `
            <span aria-hidden="true">⚙️</span>
            <span class="planning-config-trigger-label">Paramètres</span>
          `;
          menu.appendChild(trigger);
          const menuList = document.createElement('div');
          menuList.className = 'planning-config-popover';
          menuList.setAttribute('role', 'menu');
          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'planning-config-edit';
          editButton.dataset.position = slot.position;
          editButton.textContent = 'Configurer la colonne';
          editButton.setAttribute('role', 'menuitem');
          menuList.appendChild(editButton);
          menu.appendChild(menuList);
          actionCell.appendChild(menu);
          row.appendChild(actionCell);

          tbody.appendChild(row);
        });

        table.appendChild(tbody);
        wrapper.appendChild(table);
        planningConfigContainer.appendChild(wrapper);
      };

      const closePlanningConfigMenu = () => {
        if (!openPlanningConfigMenu) {
          return;
        }
        openPlanningConfigMenu.classList.remove('is-open');
        const trigger = openPlanningConfigMenu.querySelector('.planning-config-trigger');
        trigger?.setAttribute('aria-expanded', 'false');
        openPlanningConfigMenu = null;
      };

      const renderPlanningTables = () => {
        if (!planningTables) {
          return;
        }
        if (!planningSlots.length) {
          planningTables.innerHTML = '<p class="empty-planning">Chargement du planning…</p>';
          return;
        }
        const baseYear = Number(planningYearSelect?.value ?? new Date().getFullYear());
        const monthOne = Number(planningMonthOneSelect?.value ?? 0);
        const monthTwo = Number(planningMonthTwoSelect?.value ?? 0);

        const selections = [];
        if (!Number.isNaN(monthOne)) {
          selections.push({ month: monthOne, year: baseYear });
        }
        if (!Number.isNaN(monthTwo)) {
          let targetYear = baseYear;
          if (!Number.isNaN(monthOne) && monthTwo < monthOne) {
            targetYear += 1;
          }
          selections.push({ month: monthTwo, year: targetYear });
        }

        const uniqueYears = [...new Set(selections.map((selection) => selection.year))];
        const holidaysByYear = new Map(uniqueYears.map((year) => [year, getFrenchHolidays(year)]));

        planningTables.innerHTML = '';
        selections.forEach((selection) => {
          const monthSection = document.createElement('section');
          monthSection.className = 'planning-month';
          const heading = document.createElement('header');
          heading.className = 'planning-month-header';
          const title = document.createElement('h3');
          title.textContent = `${MONTH_NAMES[selection.month]} ${selection.year}`;
          heading.appendChild(title);
          monthSection.appendChild(heading);
          const table = buildPlanningTable(selection.year, selection.month, holidaysByYear.get(selection.year));
          monthSection.appendChild(table);
          planningTables.appendChild(monthSection);
        });
      };

      const closeUserModal = () => {
        editingUser = null;
        editForm.reset();
        userModalSubtitle.textContent = '';
        userModal.classList.add('hidden');
      };

      const openUserModal = (user) => {
        editingUser = user;
        const trigram = (user.trigram ?? '').trim() || user.username.slice(0, 3).toUpperCase();
        const roleLabels = {
          administrateur: 'Administrateurs',
          medecin: 'Médecins',
          remplacant: 'Remplaçants'
        };
        userModalSubtitle.textContent = `${roleLabels[user.role] ?? 'Utilisateur'} · ${user.username}`;
        editForm.elements['id'].value = user.id;
        editForm.elements['username'].value = user.username;
        editForm.elements['trigram'].value = trigram;
        editForm.elements['role'].value = user.role;
        editForm.elements['password'].value = '';
        userModal.classList.remove('hidden');
        editForm.elements['trigram'].focus();
      };

      const renderUsers = (users) => {
        userGroups.innerHTML = '';

        const roles = [
          { value: 'administrateur', label: 'Administrateurs' },
          { value: 'medecin', label: 'Médecins' },
          { value: 'remplacant', label: 'Remplaçants' }
        ];

        roles.forEach(({ value, label }) => {
          const groupUsers = users.filter((user) => user.role === value);
          const section = document.createElement('section');
          section.className = 'user-group';
          section.innerHTML = `
            <header class="user-group-header">
              <h3>${label}</h3>
              <span class="badge">${groupUsers.length}</span>
            </header>
          `;

          const list = document.createElement('div');
          list.className = 'user-grid';

          if (groupUsers.length === 0) {
            const empty = document.createElement('p');
            empty.className = 'empty-group';
            empty.textContent = 'Aucun utilisateur pour le moment.';
            list.appendChild(empty);
          } else {
            [...groupUsers]
              .sort((a, b) => a.trigram.localeCompare(b.trigram))
              .forEach((user) => {
                const trigram = (user.trigram ?? '').trim() || user.username.slice(0, 3).toUpperCase();
                const card = document.createElement('button');
                card.type = 'button';
                card.className = 'user-card';
                card.dataset.id = user.id;
                card.textContent = trigram;
                card.title = `${trigram} · ${user.username}`;
                list.appendChild(card);
              });
          }

          section.appendChild(list);
          userGroups.appendChild(section);
        });
      };

      const loadUsers = async () => {
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const { data, error } = await supabase
          .from('users')
          .select('id, username, trigram, role')
          .order('username');
        if (error) {
          console.error(error);
          usersFeedback.textContent = "Impossible de récupérer les utilisateurs.";
          return;
        }
        allUsers = data;
        usersFeedback.textContent = `${data.length} utilisateur(s).`;
        renderUsers(allUsers);
      };

      const ensurePlanningColumns = async (supabase, slots) => {
        const missing = [];
        for (let position = 1; position <= 46; position += 1) {
          if (!slots.some((slot) => slot.position === position)) {
            missing.push(getDefaultSlot(position));
          }
        }
        if (missing.length === 0) {
          return slots;
        }
        const { error } = await supabase.from('planning_columns').upsert(missing, { onConflict: 'position' });
        if (error) {
          console.error(error);
          return slots;
        }
        const { data, error: reloadError } = await supabase
          .from('planning_columns')
          .select(
            `id,
            position,
            label,
            type_code,
            type_category,
            start_time,
            end_time,
            color,
            quality_weekdays,
            quality_saturday,
            quality_sunday,
            open_mauvaise_weekdays,
            open_mauvaise_saturday,
            open_mauvaise_sunday,
            open_bonus_weekdays,
            open_bonus_saturday,
            open_bonus_sunday`
          )
          .order('position');
        if (reloadError) {
          console.error(reloadError);
          return slots;
        }
        return data ?? slots;
      };

      const loadPlanningColumns = async () => {
        if (planningLoading) {
          return;
        }
        planningLoading = true;
        if (planningFeedback) {
          planningFeedback.textContent = 'Chargement des colonnes…';
        }
        if (planningTables) {
          planningTables.innerHTML = '<p class="empty-planning">Chargement du planning…</p>';
        }
        if (planningConfigContainer) {
          planningConfigContainer.innerHTML = '<p class="empty-planning">Chargement des colonnes…</p>';
        }
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const { data, error } = await supabase
          .from('planning_columns')
          .select(
            `id,
            position,
            label,
            type_code,
            type_category,
            start_time,
            end_time,
            color,
            quality_weekdays,
            quality_saturday,
            quality_sunday,
            open_mauvaise_weekdays,
            open_mauvaise_saturday,
            open_mauvaise_sunday,
            open_bonus_weekdays,
            open_bonus_saturday,
            open_bonus_sunday`
          )
          .order('position');
        if (error) {
          console.error(error);
          if (planningFeedback) {
            planningFeedback.textContent = 'Impossible de charger les colonnes.';
          }
          if (planningTables) {
            planningTables.innerHTML = '<p class="empty-planning">Impossible de charger le planning.</p>';
          }
          if (planningConfigContainer) {
            planningConfigContainer.innerHTML = '<p class="empty-planning">Impossible de charger les colonnes.</p>';
          }
          planningLoading = false;
          return;
        }
        let slots = data ?? [];
        slots = await ensurePlanningColumns(supabase, slots);
        planningSlots = slots.map((slot) => ({
          ...slot,
          color: normalizeColor(slot.color),
          label: (() => {
            const rawLabel = typeof slot.label === 'string' ? slot.label.trim() : '';
            if (rawLabel) {
              return rawLabel;
            }
            const code = typeof slot.type_code === 'string' ? slot.type_code.trim() : '';
            return code || `Colonne ${slot.position}`;
          })(),
          type_code: ((slot.type_code ?? '').trim().toUpperCase()) || null,
          type_category: (() => {
            const rawCategory = typeof slot.type_category === 'string' ? slot.type_category.trim() : '';
            if (['Visite', 'Consultation', 'Téléconsultation'].includes(rawCategory)) {
              return rawCategory;
            }
            return inferTypeCategory(slot.type_code);
          })(),
          quality_weekdays: sanitizeQuality(slot.quality_weekdays),
          quality_saturday: sanitizeQuality(slot.quality_saturday),
          quality_sunday: sanitizeQuality(slot.quality_sunday),
          open_mauvaise_weekdays: toBoolean(slot.open_mauvaise_weekdays),
          open_mauvaise_saturday: toBoolean(slot.open_mauvaise_saturday),
          open_mauvaise_sunday: toBoolean(slot.open_mauvaise_sunday),
          open_bonus_weekdays: toBoolean(slot.open_bonus_weekdays),
          open_bonus_saturday: toBoolean(slot.open_bonus_saturday),
          open_bonus_sunday: toBoolean(slot.open_bonus_sunday)
        }));
        const total = planningSlots.length;
        if (planningFeedback) {
          planningFeedback.textContent = `${total} colonne${total > 1 ? 's' : ''} configurée${total > 1 ? 's' : ''}.`;
        }
        renderPlanningTables();
        renderPlanningConfig();
        planningLoading = false;
      };

      createForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const formData = new FormData(createForm);
        const payload = {
          username: formData.get('username').trim(),
          trigram: formatTrigram(formData.get('trigram') ?? ''),
          password: formData.get('password').trim(),
          role: formData.get('role')
        };

        if (!payload.username || !payload.password || !payload.trigram) {
          createFeedback.textContent = 'Identifiant, trigramme et mot de passe sont obligatoires.';
          return;
        }

        if (payload.trigram.length !== 3) {
          createFeedback.textContent = 'Le trigramme doit contenir exactement 3 caractères.';
          return;
        }

        const { error } = await supabase.from('users').insert(payload);
        if (error) {
          console.error(error);
          createFeedback.textContent = "Impossible de créer l'utilisateur.";
          return;
        }

        createFeedback.textContent = "Utilisateur créé.";
        createForm.reset();
      });

      createForm.addEventListener('input', () => {
        createFeedback.textContent = '';
      });

      userGroups.addEventListener('click', (event) => {
        const card = event.target.closest('.user-card');
        if (!card) {
          return;
        }
        const user = allUsers.find((candidate) => String(candidate.id) === card.dataset.id);
        if (!user) {
          return;
        }
        openUserModal(user);
      });

      closeUserModalBtn.addEventListener('click', closeUserModal);

      userModal.addEventListener('click', (event) => {
        if (event.target === userModal) {
          closeUserModal();
        }
      });

      const closeSlotModal = () => {
        editingSlot = null;
        if (slotForm) {
          slotForm.reset();
          if (slotForm.elements['color']) {
            slotForm.elements['color'].value = DEFAULT_COLOR;
          }
          if (slotForm.elements['position']) {
            slotForm.elements['position'].value = '';
          }
        }
        if (slotFeedback) {
          slotFeedback.textContent = '';
        }
        slotModal?.classList.add('hidden');
      };

      const openSlotModal = (slot) => {
        editingSlot = slot;
        if (slotFeedback) {
          slotFeedback.textContent = '';
        }
        const position = slot.position;
        if (slotModalSubtitle) {
          slotModalSubtitle.textContent = `Colonne ${String(position).padStart(2, '0')}`;
        }
        if (!slotForm) {
          return;
        }
        const labelInput = slotForm.elements['label'];
        if (labelInput) {
          labelInput.value = slot.label ?? slot.type_code ?? `Colonne ${position}`;
        }
        const typeCodeInput = slotForm.elements['typeCode'];
        if (typeCodeInput) {
          typeCodeInput.value = (slot.type_code ?? '').toUpperCase();
        }
        const typeCategorySelect = slotForm.elements['typeCategory'];
        if (typeCategorySelect) {
          const normalizedCode = (slot.type_code ?? '').trim().toUpperCase();
          const mapped = TYPE_CATEGORY_MAP.get(normalizedCode) ?? slot.type_category ?? 'Visite';
          typeCategorySelect.value = mapped;
        }
        const startInput = slotForm.elements['startTime'];
        if (startInput) {
          startInput.value = slot.start_time ?? '';
        }
        const endInput = slotForm.elements['endTime'];
        if (endInput) {
          endInput.value = slot.end_time ?? '';
        }
        const colorInput = slotForm.elements['color'];
        if (colorInput) {
          colorInput.value = normalizeColor(slot.color);
        }
        const qualityWeekdays = slotForm.elements['qualityWeekdays'];
        if (qualityWeekdays) {
          qualityWeekdays.value = sanitizeQuality(slot.quality_weekdays);
        }
        const qualitySaturday = slotForm.elements['qualitySaturday'];
        if (qualitySaturday) {
          qualitySaturday.value = sanitizeQuality(slot.quality_saturday);
        }
        const qualitySunday = slotForm.elements['qualitySunday'];
        if (qualitySunday) {
          qualitySunday.value = sanitizeQuality(slot.quality_sunday);
        }
        const openMauvaiseWeekdays = slotForm.elements['openMauvaiseWeekdays'];
        if (openMauvaiseWeekdays) {
          openMauvaiseWeekdays.value = slot.open_mauvaise_weekdays ? 'true' : 'false';
        }
        const openMauvaiseSaturday = slotForm.elements['openMauvaiseSaturday'];
        if (openMauvaiseSaturday) {
          openMauvaiseSaturday.value = slot.open_mauvaise_saturday ? 'true' : 'false';
        }
        const openMauvaiseSunday = slotForm.elements['openMauvaiseSunday'];
        if (openMauvaiseSunday) {
          openMauvaiseSunday.value = slot.open_mauvaise_sunday ? 'true' : 'false';
        }
        const openBonusWeekdays = slotForm.elements['openBonusWeekdays'];
        if (openBonusWeekdays) {
          openBonusWeekdays.value = slot.open_bonus_weekdays ? 'true' : 'false';
        }
        const openBonusSaturday = slotForm.elements['openBonusSaturday'];
        if (openBonusSaturday) {
          openBonusSaturday.value = slot.open_bonus_saturday ? 'true' : 'false';
        }
        const openBonusSunday = slotForm.elements['openBonusSunday'];
        if (openBonusSunday) {
          openBonusSunday.value = slot.open_bonus_sunday ? 'true' : 'false';
        }
        slotForm.elements['position'].value = position;
        slotModal?.classList.remove('hidden');
        labelInput?.focus();
      };

      const handleSlotSubmit = async (event) => {
        event.preventDefault();
        const formData = new FormData(slotForm);
        const position = Number(formData.get('position'));
        if (!position) {
          return;
        }
        const rawLabel = formData.get('label');
        const label = typeof rawLabel === 'string' ? rawLabel.trim() : '';
        const rawTypeCode = formData.get('typeCode');
        const typeCode = typeof rawTypeCode === 'string' ? rawTypeCode.replace(/\s+/g, '').toUpperCase() : '';
        const categoryValue = formData.get('typeCategory');
        const allowedCategories = ['Visite', 'Consultation', 'Téléconsultation'];
        const typeCategory = allowedCategories.includes(categoryValue) ? categoryValue : TYPE_CATEGORY_MAP.get(typeCode) ?? 'Visite';
        const color = normalizeColor(formData.get('color'));
        const qualityWeekdays = sanitizeQuality(formData.get('qualityWeekdays'));
        const qualitySaturday = sanitizeQuality(formData.get('qualitySaturday'));
        const qualitySunday = sanitizeQuality(formData.get('qualitySunday'));
        const openMauvaiseWeekdays = selectToBoolean(formData.get('openMauvaiseWeekdays'), true);
        const openMauvaiseSaturday = selectToBoolean(formData.get('openMauvaiseSaturday'), true);
        const openMauvaiseSunday = selectToBoolean(formData.get('openMauvaiseSunday'), true);
        const openBonusWeekdays = selectToBoolean(formData.get('openBonusWeekdays'), true);
        const openBonusSaturday = selectToBoolean(formData.get('openBonusSaturday'), true);
        const openBonusSunday = selectToBoolean(formData.get('openBonusSunday'), true);
        const startTime = formData.get('startTime') || null;
        const endTime = formData.get('endTime') || null;
        if (slotFeedback) {
          slotFeedback.textContent = 'Enregistrement en cours…';
        }
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const payload = {
          position,
          label: label || typeCode || `Colonne ${position}`,
          type_code: typeCode || null,
          type_category: typeCategory,
          start_time: startTime && startTime !== '' ? startTime : null,
          end_time: endTime && endTime !== '' ? endTime : null,
          color,
          quality_weekdays: qualityWeekdays,
          quality_saturday: qualitySaturday,
          quality_sunday: qualitySunday,
          open_mauvaise_weekdays: openMauvaiseWeekdays,
          open_mauvaise_saturday: openMauvaiseSaturday,
          open_mauvaise_sunday: openMauvaiseSunday,
          open_bonus_weekdays: openBonusWeekdays,
          open_bonus_saturday: openBonusSaturday,
          open_bonus_sunday: openBonusSunday
        };
        const { error } = await supabase.from('planning_columns').upsert(payload, { onConflict: 'position' });
        if (error) {
          console.error(error);
          if (slotFeedback) {
            slotFeedback.textContent = "Impossible d'enregistrer la colonne.";
          }
          return;
        }
        await loadPlanningColumns();
        closeSlotModal();
      };

      if (slotModal) {
        slotModal.addEventListener('click', (event) => {
          if (event.target === slotModal) {
            closeSlotModal();
          }
        });
      }

      if (slotForm) {
        slotForm.addEventListener('submit', handleSlotSubmit);
      }

      if (closeSlotModalBtn) {
        closeSlotModalBtn.addEventListener('click', () => {
          closeSlotModal();
        });
      }
      if (cancelSlotBtn) {
        cancelSlotBtn.addEventListener('click', () => {
          closeSlotModal();
        });
      }

      if (planningTables) {
        planningTables.addEventListener('click', (event) => {
          const button = event.target.closest('.planning-slot-button');
          if (!button) {
            return;
          }
          const position = Number(button.dataset.position);
          const slot = planningSlots.find((candidate) => candidate.position === position);
          if (slot) {
            openSlotModal(slot);
          }
        });
      }

      if (planningConfigContainer) {
        planningConfigContainer.addEventListener('click', (event) => {
          const trigger = event.target.closest('.planning-config-trigger');
          if (trigger) {
            const menu = trigger.closest('.planning-config-menu');
            if (!menu) {
              return;
            }
            if (openPlanningConfigMenu && openPlanningConfigMenu !== menu) {
              closePlanningConfigMenu();
            }
            const isOpen = menu.classList.toggle('is-open');
            trigger.setAttribute('aria-expanded', String(isOpen));
            openPlanningConfigMenu = isOpen ? menu : null;
            event.stopPropagation();
            return;
          }

          const button = event.target.closest('.planning-config-edit');
          if (!button) {
            return;
          }
          const position = Number(button.dataset.position);
          const slot = planningSlots.find((candidate) => candidate.position === position);
          closePlanningConfigMenu();
          if (slot) {
            openSlotModal(slot);
          }
        });
      }

      document.addEventListener('click', (event) => {
        if (!event.target.closest('.planning-config-menu')) {
          closePlanningConfigMenu();
        }
      });

      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (!userModal.classList.contains('hidden')) {
            closeUserModal();
          }
          if (slotModal && !slotModal.classList.contains('hidden')) {
            closeSlotModal();
          }
          closePlanningConfigMenu();
        }
      });

      editForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!editingUser) {
          return;
        }

        const formData = new FormData(editForm);
        const payload = {
          username: formData.get('username').trim(),
          trigram: formatTrigram(formData.get('trigram') ?? ''),
          role: formData.get('role')
        };
        const password = formData.get('password').trim();

        if (!payload.username || !payload.trigram) {
          alert('Merci de renseigner un identifiant et un trigramme.');
          return;
        }

        if (payload.trigram.length !== 3) {
          alert('Le trigramme doit contenir exactement 3 caractères.');
          return;
        }

        if (password) {
          payload.password = password;
        }

        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const { error } = await supabase.from('users').update(payload).eq('id', editingUser.id);
        if (error) {
          console.error(error);
          alert("Impossible de mettre à jour l'utilisateur.");
          return;
        }

        closeUserModal();
      });

      deleteUserBtn.addEventListener('click', async () => {
        if (!editingUser) {
          return;
        }
        if (!confirm('Supprimer cet utilisateur ?')) {
          return;
        }

        await onSupabaseReady();
        const supabase = getSupabaseClient();
        const { error } = await supabase.from('users').delete().eq('id', editingUser.id);
        if (error) {
          console.error(error);
          alert('Impossible de supprimer cet utilisateur.');
          return;
        }

        closeUserModal();
      });

      const subscribeToUserChanges = async () => {
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        usersChannel = supabase
          .channel('users-changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'users' }, () => {
            loadUsers();
          })
          .subscribe();
      };

      const subscribeToPlanningChanges = async () => {
        await onSupabaseReady();
        const supabase = getSupabaseClient();
        planningChannel = supabase
          .channel('planning-columns-changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'planning_columns' }, () => {
            loadPlanningColumns();
          })
          .subscribe();
      };

      if (planningYearSelect && planningMonthOneSelect && planningMonthTwoSelect) {
        populatePlanningControls();
        [planningYearSelect, planningMonthOneSelect, planningMonthTwoSelect].forEach((select) => {
          select.addEventListener('change', renderPlanningTables);
        });
      }

      loadUsers();
      loadPlanningColumns();
      subscribeToUserChanges();
      subscribeToPlanningChanges();

      window.addEventListener('beforeunload', () => {
        usersChannel?.unsubscribe();
        planningChannel?.unsubscribe();
      });

    </script>
  </body>
</html>
