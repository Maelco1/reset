-- ============================================================
-- SOS92 Planning - Schéma complet & corrigé (Supabase-ready)
-- Idempotent, sans SET/RESET ROLE, avec bloc RLS de dev (optionnel).
-- ============================================================

-- 1) UTILISATEURS DE BASE ------------------------------------
create table if not exists public.users (
  id bigint generated by default as identity primary key,
  username text unique not null,
  trigram text not null,
  password text not null,
  role text not null,
  created_at timestamptz not null default now()
);

-- normalisation du trigram (déjà présent dans ton script)
alter table if exists public.users
  add column if not exists trigram text;
update public.users
set trigram = coalesce(nullif(trim(trigram), ''), upper(left(username, 3)))
where trigram is null or trigram = '';
alter table if exists public.users
  alter column trigram set not null;

-- compte admin initial (admin / Melatonine)
insert into public.users (username, trigram, password, role)
values ('admin', 'ADM', 'Melatonine', 'administrateur')
on conflict (username) do nothing;

-- 2) SAISIES MEDECIN & REMPLAÇANT -----------------------------
create table if not exists public.doctor_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  type text not null,
  notes text,
  created_at timestamptz not null default now()
);
create index if not exists doctor_entries_user_id_idx
  on public.doctor_entries (user_id, date);

create table if not exists public.replacement_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  slot text not null,
  notes text,
  created_at timestamptz not null default now()
);
create index if not exists replacement_entries_user_id_idx
  on public.replacement_entries (user_id, date);

-- 3) TABLE PLANNING (TOUR 1) ---------------------------------
create table if not exists public.planning_columns (
  id bigint generated by default as identity primary key,
  position int not null unique,
  label text not null,
  type_code text not null,
  type_category text not null,
  start_time time,
  end_time time,
  color text default '#1e293b',
  quality_weekdays text default 'Normale',
  quality_saturday text default 'Normale',
  quality_sunday text default 'Normale',
  open_normale_weekdays boolean default true,
  open_normale_saturday boolean default true,
  open_normale_sunday boolean default true,
  open_bonne_weekdays boolean default true,
  open_bonne_saturday boolean default true,
  open_bonne_sunday boolean default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint planning_columns_quality_weekdays_chk check (quality_weekdays in ('Normale', 'Bonne')),
  constraint planning_columns_quality_saturday_chk check (quality_saturday in ('Normale', 'Bonne')),
  constraint planning_columns_quality_sunday_chk check (quality_sunday in ('Normale', 'Bonne')),
  constraint planning_columns_type_category_chk check (type_category in ('Visite', 'Consultation', 'Téléconsultation'))
);

-- trigger updated_at
create or replace function public.update_planning_columns_timestamp()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end; $$;

drop trigger if exists trg_planning_columns_updated_at on public.planning_columns;
create trigger trg_planning_columns_updated_at
before update on public.planning_columns
for each row execute function public.update_planning_columns_timestamp();

-- 4) TABLES PLANNING TOURS 2..6 -------------------------------
-- IMPORTANT: on copie aussi les INDEX (donc UNIQUE(position)).
create table if not exists public.planning_columns_tour2
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour3
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour4
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour5
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour6
  (like public.planning_columns including defaults including identity including indexes);

-- Filet de sécurité si certaines tables *tourN* existent déjà SANS l'UNIQUE(position)
do $$
declare t text;
begin
  foreach t in array array[
    'planning_columns_tour2',
    'planning_columns_tour3',
    'planning_columns_tour4',
    'planning_columns_tour5',
    'planning_columns_tour6'
  ]
  loop
    -- ajoute UNIQUE(position) s'il n'existe pas
    if not exists (
      select 1
      from pg_constraint
      where connamespace = 'public'::regnamespace
        and conrelid = format('public.%I', t)::regclass
        and contype = 'u'
    ) then
      execute format('alter table public.%I add constraint %I unique (position);',
                     t, t||'_position_key');
    end if;
  end loop;
end $$;

-- triggers updated_at pour chaque tour
drop trigger if exists trg_planning_columns_tour2_updated_at on public.planning_columns_tour2;
create trigger trg_planning_columns_tour2_updated_at
before update on public.planning_columns_tour2
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour3_updated_at on public.planning_columns_tour3;
create trigger trg_planning_columns_tour3_updated_at
before update on public.planning_columns_tour3
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour4_updated_at on public.planning_columns_tour4;
create trigger trg_planning_columns_tour4_updated_at
before update on public.planning_columns_tour4
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour5_updated_at on public.planning_columns_tour5;
create trigger trg_planning_columns_tour5_updated_at
before update on public.planning_columns_tour5
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour6_updated_at on public.planning_columns_tour6;
create trigger trg_planning_columns_tour6_updated_at
before update on public.planning_columns_tour6
for each row execute function public.update_planning_columns_timestamp();

-- 5) DONNÉES PAR DÉFAUT DES COLONNES (TOUR 1) -----------------
with defaults(position, type_code, color) as (
  values
    (1,'1N','#1e293b'),(2,'2N','#1e293b'),(3,'3N','#1e293b'),(4,'4C','#1e293b'),
    (5,'5S','#1e293b'),(6,'6S','#1e293b'),(7,'VIS','#1e293b'),(8,'VIS','#1e293b'),
    (9,'VIS','#1e293b'),(10,'VIS','#1e293b'),(11,'VIS','#1e293b'),(12,'TC','#1e293b'),
    (13,'C1COU','#1e293b'),(14,'C2COU','#1e293b'),(15,'C1BOU','#1e293b'),(16,'C2BOU','#1e293b'),
    (17,'PFG','#1e293b'),(18,'C1ANT','#1e293b'),(19,'C2ANT','#1e293b'),(20,'TC','#1e293b'),
    (21,'N','#1e293b'),(22,'C','#1e293b'),(23,'S','#1e293b'),(24,'VIS','#1e293b'),
    (25,'VIS','#1e293b'),(26,'VIS','#1e293b'),(27,'C1COU','#1e293b'),(28,'C2COU','#1e293b'),
    (29,'C1BOU','#1e293b'),(30,'C2BOU','#1e293b'),(31,'PFG','#1e293b'),(32,'C1ANT','#1e293b'),
    (33,'C2ANT','#1e293b'),(34,'TC','#1e293b'),(35,'VIS','#1e293b'),(36,'PFG','#1e293b'),
    (37,'VIS','#1e293b'),(38,'VIS','#1e293b'),(39,'VIS','#1e293b'),(40,'VIS','#1e293b'),
    (41,'VIS','#1e293b'),(42,'VIS','#1e293b'),(43,'TCN','#1e293b'),(44,'VIS','#1e293b'),
    (45,'VIS','#1e293b'),(46,'VIS','#1e293b')
)
insert into public.planning_columns (position, label, type_code, type_category, color)
select
  position,
  type_code,
  type_code,
  case
    when type_code in ('C1COU','C2COU','C1BOU','C2BOU','PFG','C1ANT','C2ANT','C1','C2','C3') then 'Consultation'
    when type_code in ('TC','TCN') then 'Téléconsultation'
    else 'Visite'
  end,
  color
from defaults
on conflict (position) do nothing;

-- 6) DUPLICATION DES COLONNES VERS TOURS 2..6 ------------------
-- (nécessite UNIQUE(position) sur chaque table, cf. bloc ci-dessus)
insert into public.planning_columns_tour2
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_normale_weekdays,open_normale_saturday,open_normale_sunday,
 open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_normale_weekdays,open_normale_saturday,open_normale_sunday,
  open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday
from public.planning_columns
on conflict (position) do nothing;

-- même insertion pour tours 3..6
insert into public.planning_columns_tour3
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_normale_weekdays,open_normale_saturday,open_normale_sunday,
 open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_normale_weekdays,open_normale_saturday,open_normale_sunday,
  open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour4
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_normale_weekdays,open_normale_saturday,open_normale_sunday,
 open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_normale_weekdays,open_normale_saturday,open_normale_sunday,
  open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour5
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_normale_weekdays,open_normale_saturday,open_normale_sunday,
 open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_normale_weekdays,open_normale_saturday,open_normale_sunday,
  open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour6
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_normale_weekdays,open_normale_saturday,open_normale_sunday,
 open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_normale_weekdays,open_normale_saturday,open_normale_sunday,
  open_bonne_weekdays,open_bonne_saturday,open_bonne_sunday
from public.planning_columns
on conflict (position) do nothing;

-- 7) PARAMÈTRES ADMINISTRATIFS ---------------------------------
create table if not exists public.parametres_administratifs (
  id bigint generated by default as identity primary key,
  active_tour int,
  instructions text,
  planning_year int,
  planning_month_one int,
  planning_month_two int,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint parametres_administratifs_active_tour_chk
    check (active_tour is null or (active_tour between 1 and 6)),
  constraint parametres_administratifs_month_one_chk
    check (planning_month_one is null or (planning_month_one between 0 and 11)),
  constraint parametres_administratifs_month_two_chk
    check (planning_month_two is null or (planning_month_two between 0 and 11))
);

create or replace function public.update_parametres_administratifs_timestamp()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end; $$;

drop trigger if exists trg_parametres_administratifs_updated_at on public.parametres_administratifs;
create trigger trg_parametres_administratifs_updated_at
before update on public.parametres_administratifs
for each row execute function public.update_parametres_administratifs_timestamp();

-- 8) ETAT DE PLANNING (ex “fix”) ------------------------------
create table if not exists public.planning_state (
  id text primary key,
  label text not null
);
create unique index if not exists planning_state_id_key
  on public.planning_state (id);

insert into public.planning_state (id, label)
select 'planning_gardes_state_v080', 'Planning gardes v0.80'
where not exists (select 1 from public.planning_state where id = 'planning_gardes_state_v080');

-- 9) (OPTIONNEL) RLS PERMISSIF DE DEV -------------------------
do $$
declare
  t text;
begin
  -- USERS
  execute 'alter table public.users enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='users' and policyname='users_all') then
    create policy users_all on public.users for all using (true) with check (true);
  end if;

  -- DOCTOR ENTRIES
  execute 'alter table public.doctor_entries enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='doctor_entries' and policyname='doctor_entries_all') then
    create policy doctor_entries_all on public.doctor_entries for all using (true) with check (true);
  end if;

  -- REPLACEMENT ENTRIES
  execute 'alter table public.replacement_entries enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='replacement_entries' and policyname='replacement_entries_all') then
    create policy replacement_entries_all on public.replacement_entries for all using (true) with check (true);
  end if;

  -- PLANNING (tours 1..6)  ✅ utiliser FOREACH IN ARRAY
  FOREACH t IN ARRAY ARRAY[
    'planning_columns',
    'planning_columns_tour2',
    'planning_columns_tour3',
    'planning_columns_tour4',
    'planning_columns_tour5',
    'planning_columns_tour6'
  ]
  LOOP
    execute format('alter table public.%I enable row level security', t);
    if not exists (
      select 1 from pg_policies where schemaname='public' and tablename=t and policyname='planning_all'
    ) then
      execute format('create policy planning_all on public.%I for all using (true) with check (true)', t);
    end if;
  END LOOP;
end $$;

-- 7) TABLE DES CHOIX UTILISATEURS ------------------------------
create table if not exists public.planning_choices (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete set null,
  trigram text not null,
  user_type text not null check (user_type in ('medecin', 'remplacant')),
  created_at timestamptz not null default now(),
  day date not null,
  month int not null,
  year int not null,
  column_number int not null,
  guard_nature text not null check (guard_nature in ('normale', 'bonne')),
  activity_type text not null check (activity_type in ('consultation', 'téléconsultation', 'visite')),
  choice_order int not null,
  choice_index int not null default 1,
  choice_rank int not null default 1,
  tour_number int not null,
  planning_reference text not null,
  is_active boolean not null default true,
  slot_type_code text,
  column_label text,
  planning_day_label text,
  etat text not null default 'en attente' check (etat in ('en attente', 'validé', 'refusé'))
);

create index if not exists planning_choices_user_idx
  on public.planning_choices (user_id, choice_order);
create index if not exists planning_choices_reference_idx
  on public.planning_choices (planning_reference, tour_number, choice_order);

alter table if exists public.planning_choices
  add column if not exists etat text;

update public.planning_choices
set etat = coalesce(nullif(etat, ''), 'en attente')
where etat is null or etat not in ('en attente', 'validé', 'refusé');

alter table if exists public.planning_choices
  alter column etat set default 'en attente';

alter table if exists public.planning_choices
  alter column etat set not null;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where connamespace = 'public'::regnamespace
      and conrelid = 'public.planning_choices'::regclass
      and conname = 'planning_choices_etat_check'
  ) then
    alter table public.planning_choices
      add constraint planning_choices_etat_check check (etat in ('en attente', 'validé', 'refusé'));
  end if;
end $$;

create table if not exists public.planning_choice_audit (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  actor_id bigint references public.users(id) on delete set null,
  actor_trigram text,
  actor_username text,
  action text not null check (action in ('accept', 'refuse', 'auto_promote')),
  choice_id bigint references public.planning_choices(id) on delete set null,
  target_trigram text not null,
  target_day date not null,
  target_column_number int not null,
  planning_reference text not null,
  tour_number int not null,
  reason text,
  metadata jsonb not null default '{}'::jsonb
);

create index if not exists planning_choice_audit_choice_idx
  on public.planning_choice_audit (choice_id);
create index if not exists planning_choice_audit_reference_idx
  on public.planning_choice_audit (planning_reference, tour_number);
create index if not exists planning_choice_audit_target_idx
  on public.planning_choice_audit (target_trigram, target_day);

-- 8) TABLE DE TRAVAIL POUR L'ATTRIBUTION AUTOMATIQUE ---------
create table if not exists public.auto_assignment_work_queue (
  id bigint generated by default as identity primary key,
  choice_id bigint not null references public.planning_choices(id) on delete cascade,
  planning_reference text not null,
  planning_version text,
  tour_number int not null,
  trigram text not null,
  user_id bigint references public.users(id) on delete set null,
  user_type text check (user_type in ('medecin', 'remplacant')),
  day date not null,
  column_number int not null,
  column_label text,
  planning_day_label text,
  slot_type_code text,
  guard_nature text,
  activity_type text,
  choice_index int,
  root_choice_index int,
  choice_rank int,
  consolidated_index text,
  priority int default 1,
  status text not null default 'en attente' check (status in ('en attente', 'validé', 'refusé')),
  source text default 'planning_choices',
  is_active boolean,
  created_at timestamptz not null default now(),
  metadata jsonb not null default '{}'::jsonb
);

create index if not exists auto_assignment_work_queue_reference_idx
  on public.auto_assignment_work_queue (planning_reference, tour_number);

create index if not exists auto_assignment_work_queue_trigram_idx
  on public.auto_assignment_work_queue (planning_reference, tour_number, trigram, root_choice_index);

create table if not exists public.auto_assignment_runs (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  actor_id bigint references public.users(id) on delete set null,
  actor_trigram text,
  actor_username text,
  planning_reference text not null,
  tour_number int not null,
  rotations_used int not null default 0,
  parameters jsonb not null default '{}'::jsonb,
  summary jsonb not null default '{}'::jsonb
);

create table if not exists public.auto_assignment_run_entries (
  id bigint generated by default as identity primary key,
  run_id bigint not null references public.auto_assignment_runs(id) on delete cascade,
  choice_id bigint not null references public.planning_choices(id) on delete cascade,
  action text not null check (action in ('accept', 'refuse', 'deactivate', 'promote')),
  previous_state jsonb not null default '{}'::jsonb,
  next_state jsonb not null default '{}'::jsonb,
  reason text
);

create index if not exists auto_assignment_runs_reference_idx
  on public.auto_assignment_runs (planning_reference, tour_number, created_at desc);
create index if not exists auto_assignment_run_entries_run_idx
  on public.auto_assignment_run_entries (run_id);
create index if not exists auto_assignment_run_entries_choice_idx
  on public.auto_assignment_run_entries (choice_id);
