set role postgres;

create table if not exists public.users (
  id bigint generated by default as identity primary key,
  username text unique not null,
  trigram text not null,
  password text not null,
  role text not null,
  created_at timestamptz not null default now()
);

alter table if exists public.users
  add column if not exists trigram text;

update public.users
set trigram = coalesce(nullif(trim(trigram), ''), upper(left(username, 3)))
where trigram is null or trigram = '';

alter table if exists public.users
  alter column trigram set not null;

insert into public.users (username, trigram, password, role)
values ('admin', 'ADM', 'Melatonine', 'administrateur')
on conflict (username) do nothing;

create table if not exists public.doctor_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  type text not null,
  notes text,
  created_at timestamptz not null default now()
);

create index if not exists doctor_entries_user_id_idx on public.doctor_entries (user_id, date);

create table if not exists public.replacement_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  slot text not null,
  notes text,
  created_at timestamptz not null default now()
);

create index if not exists replacement_entries_user_id_idx on public.replacement_entries (user_id, date);

create table if not exists public.planning_slots (
  id bigint generated by default as identity primary key,
  position int not null unique,
  label text not null,
  slot_type text,
  start_time time,
  end_time time,
  color text default '#3498db',
  quality text,
  active_days text[] default '{}',
  closed_on_holidays boolean default true,
  closed_on_sundays boolean default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create or replace function public.update_planning_slots_timestamp()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_planning_slots_updated_at on public.planning_slots;

create trigger trg_planning_slots_updated_at
before update on public.planning_slots
for each row
execute function public.update_planning_slots_timestamp();

reset role;
