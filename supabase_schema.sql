-- ============================================================
-- SOS92 Planning - Schéma complet & corrigé (Supabase-ready)
-- Idempotent, sans SET/RESET ROLE, avec bloc RLS de dev (optionnel).
-- ============================================================

-- 1) UTILISATEURS DE BASE ------------------------------------
create table if not exists public.users (
  id bigint generated by default as identity primary key,
  username text unique not null,
  trigram text not null,
  password text not null,
  role text not null,
  created_at timestamptz not null default now()
);

-- normalisation du trigram (déjà présent dans ton script)
alter table if exists public.users
  add column if not exists trigram text;
update public.users
set trigram = coalesce(nullif(trim(trigram), ''), upper(left(username, 3)))
where trigram is null or trigram = '';
alter table if exists public.users
  alter column trigram set not null;

-- compte admin initial (admin / Melatonine)
insert into public.users (username, trigram, password, role)
values ('admin', 'ADM', 'Melatonine', 'administrateur')
on conflict (username) do nothing;

-- 2) SAISIES MEDECIN & REMPLAÇANT -----------------------------
create table if not exists public.doctor_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  type text not null,
  notes text,
  created_at timestamptz not null default now()
);
create index if not exists doctor_entries_user_id_idx
  on public.doctor_entries (user_id, date);

create table if not exists public.replacement_entries (
  id bigint generated by default as identity primary key,
  user_id bigint not null references public.users(id) on delete cascade,
  date date not null,
  slot text not null,
  notes text,
  created_at timestamptz not null default now()
);
create index if not exists replacement_entries_user_id_idx
  on public.replacement_entries (user_id, date);

-- 3) TABLE PLANNING (TOUR 1) ---------------------------------
create table if not exists public.planning_columns (
  id bigint generated by default as identity primary key,
  position int not null unique,
  label text not null,
  type_code text not null,
  type_category text not null,
  start_time time,
  end_time time,
  color text default '#1e293b',
  quality_weekdays text default 'Mauvaise',
  quality_saturday text default 'Mauvaise',
  quality_sunday text default 'Mauvaise',
  open_mauvaise_weekdays boolean default true,
  open_mauvaise_saturday boolean default true,
  open_mauvaise_sunday boolean default true,
  open_bonus_weekdays boolean default true,
  open_bonus_saturday boolean default true,
  open_bonus_sunday boolean default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint planning_columns_quality_weekdays_chk check (quality_weekdays in ('Mauvaise', 'Bonus')),
  constraint planning_columns_quality_saturday_chk check (quality_saturday in ('Mauvaise', 'Bonus')),
  constraint planning_columns_quality_sunday_chk check (quality_sunday in ('Mauvaise', 'Bonus')),
  constraint planning_columns_type_category_chk check (type_category in ('Visite', 'Consultation', 'Téléconsultation'))
);

-- trigger updated_at
create or replace function public.update_planning_columns_timestamp()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end; $$;

drop trigger if exists trg_planning_columns_updated_at on public.planning_columns;
create trigger trg_planning_columns_updated_at
before update on public.planning_columns
for each row execute function public.update_planning_columns_timestamp();

-- 4) TABLES PLANNING TOURS 2..6 -------------------------------
-- IMPORTANT: on copie aussi les INDEX (donc UNIQUE(position)).
create table if not exists public.planning_columns_tour2
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour3
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour4
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour5
  (like public.planning_columns including defaults including identity including indexes);
create table if not exists public.planning_columns_tour6
  (like public.planning_columns including defaults including identity including indexes);

-- Filet de sécurité si certaines tables *tourN* existent déjà SANS l'UNIQUE(position)
do $$
declare t text;
begin
  foreach t in array array[
    'planning_columns_tour2',
    'planning_columns_tour3',
    'planning_columns_tour4',
    'planning_columns_tour5',
    'planning_columns_tour6'
  ]
  loop
    -- ajoute UNIQUE(position) s'il n'existe pas
    if not exists (
      select 1
      from pg_constraint
      where connamespace = 'public'::regnamespace
        and conrelid = format('public.%I', t)::regclass
        and contype = 'u'
    ) then
      execute format('alter table public.%I add constraint %I unique (position);',
                     t, t||'_position_key');
    end if;
  end loop;
end $$;

-- triggers updated_at pour chaque tour
drop trigger if exists trg_planning_columns_tour2_updated_at on public.planning_columns_tour2;
create trigger trg_planning_columns_tour2_updated_at
before update on public.planning_columns_tour2
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour3_updated_at on public.planning_columns_tour3;
create trigger trg_planning_columns_tour3_updated_at
before update on public.planning_columns_tour3
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour4_updated_at on public.planning_columns_tour4;
create trigger trg_planning_columns_tour4_updated_at
before update on public.planning_columns_tour4
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour5_updated_at on public.planning_columns_tour5;
create trigger trg_planning_columns_tour5_updated_at
before update on public.planning_columns_tour5
for each row execute function public.update_planning_columns_timestamp();

drop trigger if exists trg_planning_columns_tour6_updated_at on public.planning_columns_tour6;
create trigger trg_planning_columns_tour6_updated_at
before update on public.planning_columns_tour6
for each row execute function public.update_planning_columns_timestamp();

-- 5) DONNÉES PAR DÉFAUT DES COLONNES (TOUR 1) -----------------
with defaults(position, type_code, color) as (
  values
    (1,'1N','#1e293b'),(2,'2N','#1e293b'),(3,'3N','#1e293b'),(4,'4C','#1e293b'),
    (5,'5S','#1e293b'),(6,'6S','#1e293b'),(7,'VIS','#1e293b'),(8,'VIS','#1e293b'),
    (9,'VIS','#1e293b'),(10,'VIS','#1e293b'),(11,'VIS','#1e293b'),(12,'TC','#1e293b'),
    (13,'C1COU','#1e293b'),(14,'C2COU','#1e293b'),(15,'C1BOU','#1e293b'),(16,'C2BOU','#1e293b'),
    (17,'PFG','#1e293b'),(18,'C1ANT','#1e293b'),(19,'C2ANT','#1e293b'),(20,'TC','#1e293b'),
    (21,'N','#1e293b'),(22,'C','#1e293b'),(23,'S','#1e293b'),(24,'VIS','#1e293b'),
    (25,'VIS','#1e293b'),(26,'VIS','#1e293b'),(27,'C1COU','#1e293b'),(28,'C2COU','#1e293b'),
    (29,'C1BOU','#1e293b'),(30,'C2BOU','#1e293b'),(31,'PFG','#1e293b'),(32,'C1ANT','#1e293b'),
    (33,'C2ANT','#1e293b'),(34,'TC','#1e293b'),(35,'VIS','#1e293b'),(36,'PFG','#1e293b'),
    (37,'VIS','#1e293b'),(38,'VIS','#1e293b'),(39,'VIS','#1e293b'),(40,'VIS','#1e293b'),
    (41,'VIS','#1e293b'),(42,'VIS','#1e293b'),(43,'TCN','#1e293b'),(44,'VIS','#1e293b'),
    (45,'VIS','#1e293b'),(46,'VIS','#1e293b')
)
insert into public.planning_columns (position, label, type_code, type_category, color)
select
  position,
  type_code,
  type_code,
  case
    when type_code in ('C1COU','C2COU','C1BOU','C2BOU','PFG','C1ANT','C2ANT','C1','C2','C3') then 'Consultation'
    when type_code in ('TC','TCN') then 'Téléconsultation'
    else 'Visite'
  end,
  color
from defaults
on conflict (position) do nothing;

-- 6) DUPLICATION DES COLONNES VERS TOURS 2..6 ------------------
-- (nécessite UNIQUE(position) sur chaque table, cf. bloc ci-dessus)
insert into public.planning_columns_tour2
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
 open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
  open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday
from public.planning_columns
on conflict (position) do nothing;

-- même insertion pour tours 3..6
insert into public.planning_columns_tour3
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
 open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
  open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour4
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
 open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
  open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour5
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
 open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
  open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday
from public.planning_columns
on conflict (position) do nothing;

insert into public.planning_columns_tour6
(position,label,type_code,type_category,start_time,end_time,color,
 quality_weekdays,quality_saturday,quality_sunday,
 open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
 open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday)
select
  position,label,type_code,type_category,start_time,end_time,color,
  quality_weekdays,quality_saturday,quality_sunday,
  open_mauvaise_weekdays,open_mauvaise_saturday,open_mauvaise_sunday,
  open_bonus_weekdays,open_bonus_saturday,open_bonus_sunday
from public.planning_columns
on conflict (position) do nothing;

-- 7) ETAT DE PLANNING (ex “fix”) ------------------------------
create table if not exists public.planning_state (
  id text primary key,
  label text not null
);
create unique index if not exists planning_state_id_key
  on public.planning_state (id);

insert into public.planning_state (id, label)
select 'planning_gardes_state_v080', 'Planning gardes v0.80'
where not exists (select 1 from public.planning_state where id = 'planning_gardes_state_v080');

-- 8) (OPTIONNEL) RLS PERMISSIF DE DEV -------------------------
do $$
declare
  t text;
begin
  -- USERS
  execute 'alter table public.users enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='users' and policyname='users_all') then
    create policy users_all on public.users for all using (true) with check (true);
  end if;

  -- DOCTOR ENTRIES
  execute 'alter table public.doctor_entries enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='doctor_entries' and policyname='doctor_entries_all') then
    create policy doctor_entries_all on public.doctor_entries for all using (true) with check (true);
  end if;

  -- REPLACEMENT ENTRIES
  execute 'alter table public.replacement_entries enable row level security';
  if not exists (select 1 from pg_policies where schemaname='public' and tablename='replacement_entries' and policyname='replacement_entries_all') then
    create policy replacement_entries_all on public.replacement_entries for all using (true) with check (true);
  end if;

  -- PLANNING (tours 1..6)  ✅ utiliser FOREACH IN ARRAY
  FOREACH t IN ARRAY ARRAY[
    'planning_columns',
    'planning_columns_tour2',
    'planning_columns_tour3',
    'planning_columns_tour4',
    'planning_columns_tour5',
    'planning_columns_tour6'
  ]
  LOOP
    execute format('alter table public.%I enable row level security', t);
    if not exists (
      select 1 from pg_policies where schemaname='public' and tablename=t and policyname='planning_all'
    ) then
      execute format('create policy planning_all on public.%I for all using (true) with check (true)', t);
    end if;
  END LOOP;
end $$;
